import {
  CommonDalImplementable,
  EntityType,
  OrmFindManyOptions,
  OrmFindOneByIdOptions,
  OrmFindOneOptions,
  StringKeyObject,
} from '../dal/common-dal-implementable'
import { OrmFilterOption } from '../dal/filter'
import { Pagination } from '../dal/pagination'
import { error } from '@beecode/msh-node-error'
import { In, ObjectLiteral, ObjectType, Repository } from 'typeorm'
import { FindConditions } from 'typeorm/find-options/FindConditions'

export enum OrderType {
  ASC = 'ASC',
  DESC = 'DESC',
}
export type OrderBy = { [k: string]: OrderType }

export abstract class TypeormCommonDalImplementation<Entity extends EntityType> implements CommonDalImplementable<Entity> {
  protected readonly _entity: ObjectType<Entity>
  protected readonly _fixedProperties?: any
  protected readonly _repoFn: (entity: ObjectType<Entity>) => Repository<Entity>
  protected readonly _fixedRelations: string[]
  protected readonly _isIdAutogenerated: boolean

  public get EntityName(): string {
    return this._entity.name
  }

  protected get _Repo(): Repository<Entity> {
    return this._repoFn(this._entity)
  }

  protected constructor(params: {
    entity: ObjectType<Entity>
    fixedProperties?: FindConditions<Entity> | ObjectLiteral
    repoFn: (entity: ObjectType<Entity>) => Repository<Entity>
    fixedRelations?: string[]
    isIdAutogenerated?: boolean
  }) {
    const { fixedProperties, fixedRelations = [], repoFn, entity, isIdAutogenerated = true } = params
    this._entity = entity
    this._fixedProperties = fixedProperties
    this._repoFn = repoFn
    this._fixedRelations = fixedRelations
    this._isIdAutogenerated = isIdAutogenerated
  }

  protected static _orderAdapter(sortByList?: string[]): OrderBy {
    if (!sortByList) return {}
    return Object.fromEntries(
      sortByList.map((o) => {
        if (o.charAt(0) === '-') return [o.slice(1), OrderType.DESC]
        return [o, OrderType.ASC]
      })
    )
  }

  protected _filterToWhereArray(filter: OrmFilterOption): StringKeyObject[] {
    if (Array.isArray(filter)) return filter
    return [filter]
  }

  protected _paginationToWherePagination(pagination?: Pagination): { take: number; skip: number } | undefined {
    if (!pagination) return undefined
    return { take: pagination.pageSize, skip: (pagination.page - 1) * pagination.pageSize }
  }

  public async findOne(params: OrmFindOneOptions): Promise<Entity> {
    const { filter, relations = [] } = params
    const whereArray = this._filterToWhereArray(filter)

    const result = await this._Repo.findOne({
      where: whereArray.map((where) => ({ ...(where as FindConditions<Entity> | ObjectLiteral), ...this._fixedProperties })),
      relations: [...this._fixedRelations, ...relations],
    })
    if (!result) throw error.client.notFound(`${this.EntityName} not found`)
    return result
  }

  public async findOneById(id: string, options: OrmFindOneByIdOptions = {}): Promise<Entity> {
    return this.findOne({ ...options, filter: { id } })
  }

  public async findMany(params?: OrmFindManyOptions): Promise<Entity[]> {
    const { filter = {}, relations = [], sortByList, pagination } = params ?? {}
    const whereArray = this._filterToWhereArray(filter)
    const wherePagination = this._paginationToWherePagination(pagination)

    return this._Repo.find({
      where: whereArray.map((where) => ({ ...(where as FindConditions<Entity> | ObjectLiteral), ...this._fixedProperties })),
      relations: [...this._fixedRelations, ...relations],
      ...wherePagination,
      ...(sortByList && { order: TypeormCommonDalImplementation._orderAdapter(sortByList) as any }),
    })
  }

  public async addBulk(entities: Partial<Entity>[]): Promise<Entity[]> {
    const cleanEntitiesWithFixedProps = entities.map((entity) => {
      const { id: _, ...cleanEntity } = entity
      return { ...cleanEntity, ...this._fixedProperties }
    })
    return this._Repo.save(cleanEntitiesWithFixedProps)
  }

  public async editBulk(entities: Partial<Entity>[]): Promise<Entity[]> {
    if (entities.find((entity) => !entity.id || entity.id.trim() === '')) {
      throw error.server.internalServerError(`Id is mandatory for ${this.EntityName} for edit action`)
    }
    const results = await this._Repo.save(entities.map((entity) => ({ ...entity, ...this._fixedProperties })))
    if (!results) throw error.server.internalServerError(`Unable to edit ${this.EntityName}`)
    return results
  }

  public async removeBulk(entities: Entity[]): Promise<void> {
    if (entities.find((entity) => !entity.id || entity.id.trim() === '')) {
      throw error.server.internalServerError(`Id is mandatory for ${this.EntityName} for remove action`)
    }
    const result = await this._Repo.remove(entities.map((entity) => ({ ...entity, ...this._fixedProperties })))
    if (!result) throw error.server.internalServerError(`Error remove ${this.EntityName}`)
  }

  public async removeByIds(ids: string[]): Promise<void> {
    const result = await this._Repo.delete({ id: In(ids), ...this._fixedProperties })
    if ((result.affected ?? 0) === 0) throw error.server.internalServerError(`Error deleting ${this.EntityName}`)
    // if ((result.affected ?? 0) !== ids.length) logger().warn(`Error deleting ${this.EntityName}`)
  }
}
