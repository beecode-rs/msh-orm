"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeormCommonDalImplementation = exports.OrderType = void 0;
const msh_node_error_1 = require("@beecode/msh-node-error");
const typeorm_1 = require("typeorm");
var OrderType;
(function (OrderType) {
    OrderType["ASC"] = "ASC";
    OrderType["DESC"] = "DESC";
})(OrderType = exports.OrderType || (exports.OrderType = {}));
class TypeormCommonDalImplementation {
    constructor(params) {
        const { fixedProperties, fixedRelations = [], repoFn, entity, isIdAutogenerated = true } = params;
        this._entity = entity;
        this._fixedProperties = fixedProperties;
        this._repoFn = repoFn;
        this._fixedRelations = fixedRelations;
        this._isIdAutogenerated = isIdAutogenerated;
    }
    get EntityName() {
        return this._entity.name;
    }
    get _Repo() {
        return this._repoFn(this._entity);
    }
    static _orderAdapter(sortByList) {
        if (!sortByList)
            return {};
        return Object.fromEntries(sortByList.map((o) => {
            if (o.charAt(0) === '-')
                return [o.slice(1), OrderType.DESC];
            return [o, OrderType.ASC];
        }));
    }
    _filterToWhereArray(filter) {
        if (Array.isArray(filter))
            return filter;
        return [filter];
    }
    _paginationToWherePagination(pagination) {
        if (!pagination)
            return undefined;
        return { take: pagination.pageSize, skip: (pagination.page - 1) * pagination.pageSize };
    }
    async findOne(params) {
        const { filter, relations = [] } = params;
        const whereArray = this._filterToWhereArray(filter);
        const result = await this._Repo.findOne({
            where: whereArray.map((where) => (Object.assign(Object.assign({}, where), this._fixedProperties))),
            relations: [...this._fixedRelations, ...relations],
        });
        if (!result)
            throw msh_node_error_1.error.client.notFound(`${this.EntityName} not found`);
        return result;
    }
    async findOneById(id, options = {}) {
        return this.findOne(Object.assign(Object.assign({}, options), { filter: { id } }));
    }
    async findMany(params) {
        const { filter = {}, relations = [], sortByList, pagination } = params !== null && params !== void 0 ? params : {};
        const whereArray = this._filterToWhereArray(filter);
        const wherePagination = this._paginationToWherePagination(pagination);
        return this._Repo.find(Object.assign(Object.assign({ where: whereArray.map((where) => (Object.assign(Object.assign({}, where), this._fixedProperties))), relations: [...this._fixedRelations, ...relations] }, wherePagination), (sortByList && { order: TypeormCommonDalImplementation._orderAdapter(sortByList) })));
    }
    async addBulk(entities) {
        const cleanEntitiesWithFixedProps = entities.map((entity) => {
            const { id: _ } = entity, cleanEntity = __rest(entity, ["id"]);
            return Object.assign(Object.assign({}, cleanEntity), this._fixedProperties);
        });
        return this._Repo.save(cleanEntitiesWithFixedProps);
    }
    async editBulk(entities) {
        if (entities.find((entity) => !entity.id || entity.id.trim() === '')) {
            throw msh_node_error_1.error.server.internalServerError(`Id is mandatory for ${this.EntityName} for edit action`);
        }
        const results = await this._Repo.save(entities.map((entity) => (Object.assign(Object.assign({}, entity), this._fixedProperties))));
        if (!results)
            throw msh_node_error_1.error.server.internalServerError(`Unable to edit ${this.EntityName}`);
        return results;
    }
    async removeBulk(entities) {
        if (entities.find((entity) => !entity.id || entity.id.trim() === '')) {
            throw msh_node_error_1.error.server.internalServerError(`Id is mandatory for ${this.EntityName} for remove action`);
        }
        const result = await this._Repo.remove(entities.map((entity) => (Object.assign(Object.assign({}, entity), this._fixedProperties))));
        if (!result)
            throw msh_node_error_1.error.server.internalServerError(`Error remove ${this.EntityName}`);
    }
    async removeByIds(ids) {
        var _a;
        const result = await this._Repo.delete(Object.assign({ id: (0, typeorm_1.In)(ids) }, this._fixedProperties));
        if (((_a = result.affected) !== null && _a !== void 0 ? _a : 0) === 0)
            throw msh_node_error_1.error.server.internalServerError(`Error deleting ${this.EntityName}`);
        // if ((result.affected ?? 0) !== ids.length) logger().warn(`Error deleting ${this.EntityName}`)
    }
}
exports.TypeormCommonDalImplementation = TypeormCommonDalImplementation;
//# sourceMappingURL=typeorm-common-dal-implementation.js.map